# 设计模式

### 何为模式

模式是在特定情况下人们解决某类重复出现问题的一套成功或有效的解决方案

---

我们在设计代码时，向来都需要考虑其可维护性、可扩展性、可复用性。根据这些考量，专家们提出如下设计原则。

## 7 种常用的面向对象设计原则

### 单一职责原则

> 单一职责原则(Single Responsibility Principle, SRP)：一个类只负责一个功能领域中的相应职责。

目的是为了实现**高内聚，低耦合**，设计人员需要发现类的不同职责并将其分离，将不同的职责封装在不同的类中，也就是将不同的变化原因封装在不同的类中。就是让一个类只负责一件事，将关联性强的内容聚合到一个类中。

### 开闭原则

> 一个软件应当对扩展开放，对修改关闭。即软件实体应当尽量在不修改原有代码的情况下进行扩展

为了满足开闭原则，需要对系统进行抽象化设计，**抽象化是开闭原则的关键**。

**实现：可以为系统定义一个相对稳定的抽象层，而将不同的实现行为移至具体的实现层中完成**。在很多面向对象编程语言中都提供了接口、抽象类等机制，可以通过它们定义系统的抽象层，再通过具体类来进行扩展。如果需要修改系统的行为，无须对抽象层进行任何改动，只需要增加新的具体类来实现新的业务功能即可，实现在不修改已有代码的基础上扩展系统的功能，达到开闭原则的要求。

### 里氏代换原则

> 里氏代换原则(Liskov Substitution Principle, LSP)：所有引用父类的地方必须能透明地使用其子类的对象。

在软件中将一个父类对象替换成它的子类对象，程序将不会产生任何错误和异常，反过来则不成立，如果一个软件实体使用的是一个子类对象的话，那么它不一定能够使用父类对象。

实现注意：

1. 子类所有方法必须在父类中声明，或子类必须实现父类中声明的所有方法。根据里氏代换原则，为了保证系统的扩展性，在程序中通常使用父类来进行定义，如果一个方法只存在子类中，在父类中不提供相应的声明，则无法在以父类定义的对象中使用该方法。

2. 我们在运用里氏代换原则时，尽量把父类设计为抽象类或者接口，让子类继承父类或实现父接口，并实现在父类中声明的方法，运行时，子类实例替换父类实例，我们可以很方便地扩展系统的功能，同时无须修改原有子类的代码，

### 依赖倒转原则

> 依赖倒转原则(Dependency Inversion Principle, DIP)：抽象不应依赖于细节，细节应该依赖于抽象。换言之，也就是要针对接口编程，而不是针对实现编程。

1. 高层模块不应该直接依赖于底层模块的具体实现，而应该依赖于底层的抽象。换言之，模块间的依赖是通过抽象发生，实现类之间不发生直接的依赖关系，其依赖关系是通过接口或抽象类产生的。
2. 接口和抽象类不应该依赖于实现类，而实现类依赖接口或抽象类。这一点其实不用多说，很好理解，“面向接口编程”思想正是这点的最好体现。

目的：降低层与层之间的耦合。

Good Demo: [https://segmentfault.com/a/1190000010307619](https://segmentfault.com/a/1190000010307619)

### 接口隔离原则

> 接口隔离原则(interface-segregation principles，ISP)：类间的依赖关系应该建立在最小的接口上

也就是说减少依赖。

比如说，在设计一个交通方法的类。可能有人会为了省事，设计了一个很臃肿的接口，叫做交通工具接口。然后里面包含了自行车，摩托车，小汽车等等。然而当我只要自行车和小汽车的时候，我却必须实现一个摩托车的方法（因为“类中必须实现接口中定义的所有方法”）。所以在这儿我们可以考虑将摩托车的方法拆分出去。

### 合成复用原则

> 合成复用原则(Composite Reuse Principle, CRP)：尽量使用对象组合，而不是继承来达到复用的目的

React.js 有一文：[https://reactjs.org/docs/composition-vs-inheritance.html](https://reactjs.org/docs/composition-vs-inheritance.html)

这一原则很好理解，从万能的积木就能看出来。

### 迪米特原则

> 迪米特原则 (Law of demeter，LOD)： 一个软件实体应当尽可能少地与其他实体发生相互作用

为了降低类之间的耦合，使系统功能模块相对独立。不希望类与类之间直接发生联系，如有必要，可以使用中介类。但中介类太多会增加系统复杂度。

设计模式的门面模式（Facade）和中介模式（Mediator），都是迪米特法则应用的例子。
