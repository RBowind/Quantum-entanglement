# 工厂模式

> 工厂模式是为了解耦，把对象的创建和使用的过程分开。

比如 MySQL 数据库实例的创建。

工厂模式可以降低代码重复。
工厂管理了对象的创建逻辑，使用者并不需要知道具体的创建过程，只管使用即可，减少了使用者因为创建逻辑导致的错误。

#### 适用场景：

- 对象的创建过程/实例化准备很复杂，需要初始化很多参数，查询数据库等
- 类本身有很多子类，这些类的创建过程在业务中容易发生改变，或者对类的调用发生改变。

## Simple Factory Pattern

> 定义一个工厂类，他可以根据参数的不同返回不同类的实例，被创建的实例通常都具有共同的父类。因为在简单工厂模式中，用于创建实例的方法是静态（static）方法，因此也称 Static Factory Pattern

简单工厂模式的要点在于：当你需要什么，只需要传入一个正确的参数，就可以获取你所需要的对象，而无须知道其创建细节。

[实现代码](https://blog.csdn.net/lovelion/article/details/9300657)

#### 缺点：

- 工厂类集中了所有产品的创建逻辑，指责过重。一旦不能正常工作，整个系统都要受到影响。
- 使用简单工厂模式势必会增加系统中类的个数（引入新的工厂类），增加了系统的复杂度和理解难度。
- 系统扩展困难，一旦添加新产品就不得不修改工厂逻辑，产品类型较多时，可能造成工厂逻辑过于复杂，不利于系统的扩展和维护。
- 由于使用了静态工厂方法，无法继承。

#### 适用场景

- 工厂类负责创建的对象比较少，由于创建的对象比较少，不会造成工厂方法中业务逻辑太过复杂。
- 客户端只知道工厂类的参数，对于如何创建并不关心。

## Factory Method Pattern

在简单工厂模式中，该工厂类处于对产品类进行实例化的中心位置，它需要知道每一个产品对象的创建细节，并决定何时实例化哪一个产品类。简单工厂模式最大的缺点就是当有新产品要加入到系统中时，必须修改工厂类，需要在其中加入必要的业务逻辑，这违背了开闭原则。诸多缺点上已描述。

在工厂方法模式中，我们**不再提供一个统一的工厂类来创建所有产品对象，而是针对不同的产品提供不同的工厂，系统提供一个与产品等级结构对应的工厂等级结构**。

> Factory Method Pattern：定义一个用于创建对象的接口，让子类决定将哪一个类实例化。工厂方法模式让一个类实例化延迟到其子类。又称虚拟构造器模式（Virtual Constructor Pattern）或多态工厂模式（Polymorphic Factory Pattern）

有时候，为了进一步简化客户端使用，还可以对客户端隐藏工厂方法。此时，在工厂类中将直接调用产品类的业务方法。若此，结构图如下：
![https://design-patterns.readthedocs.io/zh_CN/latest/creational_patterns/factory_method.html](https://design-patterns.readthedocs.io/zh_CN/latest/_images/loger.jpg)

#### 缺点

- 添加新产品时，需要编写新的具体产品类，而且还要提供与之对应的具体工厂类，系统中类的个数将成对增加，在一定程度上增加了系统的复杂度。
- 考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层定义，增加了系统的抽象性和理解难度。实现也麻烦了。

#### 适用场景

- 客户端不知道它所需要的对象的类。
- 抽象工厂类通过其子类来指定创建哪个对象。

## Abstract Factory Pattern

工厂方法模式通过引入工厂等级结构，解决了简单工厂模式中工厂类职责太重的问题，但由于工厂方法模式中的每个工厂只生产一类产品，可能会导致系统中存在大量的工厂类，势必会增加系统的开销。此时，我们可以考虑将一些相关的产品组成一个“产品族”，由同一个工厂来统一生产。

当系统所提供的工厂生产的具体产品并不是一个简单的对象，而是多个位于不同产品等级结构、属于不同类型的具体产品时就可以使用抽象工厂模式。**抽象工厂模式是所有形式的工厂模式中最为抽象和最具一般性的一种形式**。

![alt](https://design-patterns.readthedocs.io/zh_CN/latest/_images/AbatractFactory.jpg)
![菜鸟](./abstractFactory.png)

> Abstract Factory Pattern：提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。

**在抽象工厂模式中，增加新的产品族很方便，但是增加新的产品等级结构很麻烦，抽象工厂模式的这种性质称为“开闭原则”的倾斜性。** 比如上图，如果增加一个联想品牌，十分简单，符合开闭原则；但是如果增加一个新产品耳麦，那么父类到子类全部需要修改，违背了开闭原则。

#### 适用场景

- 一个系统不应当依赖于产品类实例如何被创建、组合和表达的细节，这对于所有类型的工厂模式都是很重要的，用户无须关心对象的创建过程：将对象的创建和使用解耦。
- 系统中有多余一个的产品族，而每次只使用其中某一产品族。可以通过配置文件等方式使得用户可以动态改变产品族，也可以很方便地增加新的产品族。
- 属于同一个产品族的产品将在一起使用。
- 产品等级结构稳定，设计完成后，不会向系统中增加新的产品等级结构或者删除已有的产品等级结构。
